/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/** This code is generated, do not edit by hand. **/
<#import "ProxyBinding.fm" as Proxy>

#include "${packageName}.${proxyClassName}.h"

#include "JNIUtil.h"
#include "TypeConverter.h"
#include "ProxyFactory.h"

using namespace v8;

namespace titanium {

Persistent<FunctionTemplate> ${proxyClassName}::proxyTemplate = Persistent<FunctionTemplate>();
jclass ${proxyClassName}::javaClass = NULL;

// Proxy Factory ---------------------------------------------------------

class ${proxyClassName}Factory : public ProxyFactory
{
public:
	virtual Handle<Object> create(jobject javaObject)
	{
		HandleScope scope;

		Local<Function> creator = ${proxyClassName}::proxyTemplate->GetFunction();
		Local<Value> external = External::New(javaObject);
		Local<Object> proxyObject = creator->NewInstance(1, &external);
		return proxyObject;
	}
};

${proxyClassName}::${proxyClassName}(jobject javaObject) : JavaObject(javaObject)
{
}

void ${proxyClassName}::Initialize(Handle<Object> ti, JNIEnv* env)
{
	// Query the Java class for this proxy.
	javaClass = env->FindClass("${packageName?replace('.','/')}/${proxyClassName}");

	// Register a proxy factory for this type.
	ProxyFactory::setFactoryForClass(new ${proxyClassName}Factory, javaClass);

	HandleScope scope;

	Local<FunctionTemplate> t = FunctionTemplate::New(${proxyClassName}::Constructor);
	proxyTemplate = Persistent<FunctionTemplate>::New(t);
	proxyTemplate->InstanceTemplate()->SetInternalFieldCount(1);
	proxyTemplate->SetClassName(String::NewSymbol("${proxyAttrs.name}"));

	<@Proxy.listMethods ; isFirst, name, method, signature>
	V8_SET_PROTOTYPE_METHOD(proxyTemplate, "${name}", ${proxyClassName}::${name});
	</@Proxy.listMethods>

	ti->Set(String::NewSymbol("${proxyAttrs.name}"), proxyTemplate->GetFunction());
}

Handle<Value> ${proxyClassName}::Constructor(const Arguments& args)
{
	assert(args.IsConstructCall());
	HandleScope scope;
	jobject javaObject = NULL;

	// If this constructor is called from the proxy factory,
	// the first argument will be an External that wraps
	// the pre-created jobject.
	if (args.Length() == 1)
	{
		Local<Value> firstArg = args[0];
		if (firstArg->IsExternal())
			javaObject = (jobject)External::Unwrap(firstArg);
	}

	// If this constructor is called from JavaScript land,
	// we must construct the Java object before returning
	// a new proxy object to V8.
	if (!javaObject)
	{
		<#-- TODO: validate and convert arguments to jvalue array -->

		<#-- TODO: Call constructor on Java class for the type we are proxying -->
	}

	// Create proxy and set internal field.
	${proxyClassName}* proxy = new ${proxyClassName}(javaObject);
	proxy->Wrap(args.Holder());

	return args.This();
}

// Methods ---------------------------------------------------------------
<@Proxy.listMethods ; isFirst, name, method, signature>
static jmethodID ${name}_methodID = JNIUtil::getJNIEnv()->GetMethodID(${proxyClassName}::javaClass, "${name}", "${signature}");

Handle<Value> ${proxyClassName}::${name}(const Arguments& args)
{
	HandleScope scope;
	JNIEnv *env = JNIUtil::getJNIEnv();
	if (!env) return ThrowException(Exception::Error(String::New("couldn't init JNIEnv")));

	<@Proxy.verifyAndConvertArguments method.args />
	<@Proxy.callJNIMethod method.returnType, "${name}_methodID", "${proxyClassName}::javaClass", "jArguments" ;
		hasResult, resultVar>
	<#if hasResult>
	return ${resultVar};
	<#else>
	return v8::Undefined();
	</#if>
	</@Proxy.callJNIMethod>
}

</@Proxy.listMethods>

} // namespace titanium

