/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/** This code is generated, do not edit by hand. **/
<#import "ProxyBinding.fm" as Proxy>

#include "${packageName}.${proxyClassName}.h"

#include "JNIUtil.h"
#include "JSException.h"
#include "ProxyFactory.h"
#include "TypeConverter.h"

<@Proxy.listChildModules ; isFirst, childModule>
#include "${childModule.proxyClassName}.h"
</@Proxy.listChildModules>

using namespace v8;

namespace titanium {

Persistent<FunctionTemplate> ${proxyClassName}::proxyTemplate = Persistent<FunctionTemplate>();
jclass ${proxyClassName}::javaClass = NULL;

${proxyClassName}::${proxyClassName}(jobject javaObject) : JavaObject(javaObject)
{
}

void ${proxyClassName}::Initialize(Handle<Object> ti, JNIEnv* env)
{
	// Query the Java class for this proxy.
	javaClass = env->FindClass("${packageName?replace('.','/')}/${proxyClassName}");

	HandleScope scope;

	Local<FunctionTemplate> t = FunctionTemplate::New(${proxyClassName}::Constructor);
	proxyTemplate = Persistent<FunctionTemplate>::New(t);
	proxyTemplate->InstanceTemplate()->SetInternalFieldCount(1);
	proxyTemplate->SetClassName(String::NewSymbol("${proxyAttrs.name}"));

	<@Proxy.listMethods ; isFirst, name, method, signature>
	V8_SET_PROTOTYPE_METHOD(proxyTemplate, "${name}", ${proxyClassName}::${name});
	</@Proxy.listMethods>

	Local<Function> proxyConstructor = proxyTemplate->GetFunction();
	ti->Set(String::NewSymbol("${proxyAttrs.name}"), proxyTemplate->GetFunction());

	// Initialize child proxies and modules.
	<@Proxy.listChildModules ; isFirst, childModule>
	${childModule.name}Module::Initialize(proxyConstructor, env);
	</@Proxy.listChildModules>

	// Register proxies with factory.
	ProxyFactory::registerProxyPair(javaClass, *proxyTemplate);
}

Handle<Value> ${proxyClassName}::Constructor(const Arguments& args)
{
    if (!args.IsConstructCall())
        return JSException::CalledConstructor();

	HandleScope scope;
    Local<Object> v8Proxy = args.This();

    // If ProxyFactory::createV8Proxy invoked us, unwrap
    // the pre-created Java proxy it sent.
    jobject javaProxy = ProxyFactory::unwrapJavaProxy(args);
    if (!javaProxy)
        javaProxy = ProxyFactory::createJavaProxy(javaClass, v8Proxy, args);

    ${proxyClassName}* v8ProxyNative = new ${proxyClassName}(javaProxy);
    v8ProxyNative->Wrap(v8Proxy);

	return v8Proxy;
}

// Methods ---------------------------------------------------------------
<@Proxy.listMethods ; isFirst, name, method, signature>
Handle<Value> ${proxyClassName}::${name}(const Arguments& args)
{
	HandleScope scope;
	JNIEnv *env = JNIUtil::getJNIEnv();
	if (!env)
		return JSException::GetJNIEnvironmentError();

	static jmethodID methodID = NULL;
	if (!methodID) {
		methodID = env->GetMethodID(${proxyClassName}::javaClass, "${name}", "${signature}");
		if (!methodID)
			return JSException::Error("Couldn't find proxy method '${name}' with signature '${signature}'");
	}

	${proxyClassName}* proxy = NativeObject::Unwrap<${proxyClassName}>(args.Holder());

	<@Proxy.verifyAndConvertArguments method.args />
	<@Proxy.callJNIMethod method.returnType, "methodID", "proxy->getJavaObject()", "jArguments" ;
		hasResult, resultVar>
	<#if hasResult>
	return ${resultVar};
	<#else>
	return v8::Undefined();
	</#if>
	</@Proxy.callJNIMethod>
}

</@Proxy.listMethods>

} // namespace titanium

