/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/** This code is generated, do not edit by hand. **/
<#import "ProxyBinding.fm" as Proxy>

#include "${packageName}.${proxyClassName}.h"

#include "JNIUtil.h"
#include "TypeConverter.h"
#include "ProxyFactory.h"

using namespace v8;

namespace titanium {

Persistent<FunctionTemplate> ${proxyClassName}::proxyTemplate = Persistent<FunctionTemplate>();
jclass ${proxyClassName}::javaClass = NULL;

// Proxy Factory ---------------------------------------------------------

class ${proxyClassName}Factory : public ProxyFactory
{
public:
	virtual Handle<Object> create(jobject javaobject)
	{
		// TODO: call NewInstance() on template and return new object.
		HandleScope scope;
		return Object::New();
	}
};

${proxyClassName}::${proxyClassName}(jobject javaObject) : JavaObject(javaObject)
{
}

void ${proxyClassName}::Initialize(Handle<Object> ti, JNIEnv* env)
{
	// Query the Java class for this proxy.
	javaClass = env->FindClass("${packageName?replace('.','/')}/${proxyClassName}");

	// Register a proxy factory for this type.
	ProxyFactory::setFactoryForClass(new ${proxyClassName}Factory, javaClass);

	HandleScope scope;

	Local<FunctionTemplate> t = FunctionTemplate::New(${proxyClassName}::Constructor);
	proxyTemplate = Persistent<FunctionTemplate>::New(t);
	proxyTemplate->InstanceTemplate()->SetInternalFieldCount(1);
	proxyTemplate->SetClassName(String::NewSymbol("${proxyAttrs.name}"));

	<@Proxy.listMethods ; isFirst, name, method, signature>
	V8_SET_PROTOTYPE_METHOD(proxyTemplate, "${name}", ${proxyClassName}::${name});
	</@Proxy.listMethods>

	ti->Set(String::NewSymbol("${proxyAttrs.name}"), proxyTemplate->GetFunction());
}

Handle<Value> ${proxyClassName}::Constructor(const Arguments& args)
{
	<#-- TODO: validate and convert arguments to jvalue array -->

	<#-- TODO: Call constructor on Java class for the type we are proxying -->

	<#-- Create proxy object and wrap into the V8 Object's internal field -->
	${proxyClassName}* proxy = new ${proxyClassName}(NULL);
	proxy->Wrap(args.Holder());

	return args.This();
}

// Methods ---------------------------------------------------------------
<@Proxy.listMethods ; isFirst, name, method, signature>
static jmethodID ${name}_methodID = NULL;

Handle<Value> ${proxyClassName}::${name}(const Arguments& args)
{
	HandleScope scope;
	JNIEnv *env = JNIUtil::getJNIEnv();
	if (!env) return ThrowException(Exception::Error(String::New("couldn't init JNIEnv")));

	static jmethodID ${name}_methodID = NULL;
	if (!${name}_methodID) {
		${name}_methodID = env->GetMethodID(${proxyClassName}::javaClass, "${name}", "${signature}");
		if (!${name}_methodID) {
			return ThrowException(Exception::Error(String::New("Couldn't find method: ${proxyClassName}.${name} ${signature}")));
		}
	}

	<@Proxy.verifyAndConvertArguments method.args />
	<@Proxy.callJNIMethod method.returnType, "${name}_methodID", "${proxyClassName}::javaClass", "jArguments" ;
		hasResult, resultVar>
	<#if hasResult>
	return ${resultVar};
	<#else>
	return v8::Undefined();
	</#if>
	</@Proxy.callJNIMethod>
}

</@Proxy.listMethods>

} // namespace titanium

