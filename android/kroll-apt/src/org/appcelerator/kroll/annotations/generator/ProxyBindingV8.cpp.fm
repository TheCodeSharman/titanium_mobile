/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/** This code is generated, do not edit by hand. **/
<#import "ProxyBinding.fm" as Proxy>

#include "${packageName}.${proxyClassName}.h"

#include "AndroidUtil.h"
#include "EventEmitter.h"
#include "JNIUtil.h"
#include "JSException.h"
#include "ProxyFactory.h"
#include "TypeConverter.h"
<#if isModule>

<@Proxy.listChildModules ; isFirst, childModule>
#include "${childModule.proxyClassName}.h"
</@Proxy.listChildModules>

<@Proxy.listCreateProxies ; isFirst, createProxy>
#include "${createProxy.proxyClassName}.h"
</@Proxy.listCreateProxies>
</#if>

<#if superProxyClassName != "EventEmitter">
#include "${superPackageName}.${superProxyClassName}.h"
</#if>

#define TAG "${proxyClassName}"

using namespace v8;

<@Proxy.openNamespace/>

<#assign className = Proxy.className(proxyClassName)>

Persistent<FunctionTemplate> ${className}::proxyTemplate = Persistent<FunctionTemplate>();
jclass ${className}::javaClass = NULL;

${className}::${className}(jobject javaObject) : JavaObject(javaObject)
{
}

void ${className}::Initialize(Handle<Object> ti)
{
	LOGD(TAG, "Initialize");

	<#-- Query the class for the Java proxy -->
	javaClass = JNIUtil::findClass("${packageName?replace('.','/')}/${className}");

	HandleScope scope;
	Handle<FunctionTemplate> t = ProxyFactory::inheritProxyTemplate(
	<#if superProxyClassName != "EventEmitter">
		${superProxyClassName?replace("BindingGen", "")}::proxyTemplate,
	<#else>
		EventEmitter::constructorTemplate,
	</#if>
		javaClass, "${proxyAttrs.name}");

	proxyTemplate = Persistent<FunctionTemplate>::New(t);

	// Method bindings -----------------------------------------------------------
	<@Proxy.listMethods ; isFirst, name, method, signature>
	V8_SET_PROTOTYPE_METHOD(proxyTemplate, "${name}", ${className}::${name});
	</@Proxy.listMethods>

	Local<Function> proxyConstructor = proxyTemplate->GetFunction();
	<#if isModule>
	Local<Object> moduleInstance = proxyConstructor->NewInstance();
	ti->Set(String::NewSymbol("${proxyAttrs.name}"), moduleInstance);
	<#else>
	ti->Set(String::NewSymbol("${proxyAttrs.name}"), proxyConstructor);
	</#if>
}

// Methods ---------------------------------------------------------------
<@Proxy.listMethods ; isFirst, name, method, signature>
Handle<Value> ${className}::${name}(const Arguments& args)
{
	LOGD(TAG, "${name}()");

	HandleScope scope;
	JNIEnv *env = JNIScope::getEnv();
	if (!env) {
		return JSException::GetJNIEnvironmentError();
	}

	<#-- Lazy initialize method ID for the Java proxy. -->
	static jmethodID methodID = NULL;
	if (!methodID) {
		methodID = env->GetMethodID(${className}::javaClass, "${name}", "${signature}");
		if (!methodID) {
			return JSException::Error("Couldn't find proxy method '${name}' with signature '${signature}'");
		}
	}

	JavaObject* proxy = NativeObject::Unwrap<JavaObject>(args.Holder());

	<#if method.args?size &gt; 0>
	<@Proxy.verifyAndConvertArguments method.args />
	<#else>
	jvalue* jArguments = 0;
	</#if>

	<@Proxy.callJNIMethod method.returnType, "methodID", "proxy->getJavaObject()", "jArguments" ;
		hasResult, resultVar>
	<#if hasResult>
	return ${resultVar};
	<#else>
	return v8::Undefined();
	</#if>
	</@Proxy.callJNIMethod>
}

</@Proxy.listMethods>

<@Proxy.closeNamespace/>
