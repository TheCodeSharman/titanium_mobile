/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/** This code is generated, do not edit by hand. **/
<#import "ProxyBinding.fm" as Proxy>

#include "${packageName}.${proxyClassName}.h"

#include "AndroidUtil.h"
#include "EventEmitter.h"
#include "JNIUtil.h"
#include "JSException.h"
#include "ProxyFactory.h"
#include "TypeConverter.h"
<#if isModule>

<@Proxy.listChildModules ; isFirst, childModule>
#include "${childModule.proxyClassName}.h"
</@Proxy.listChildModules>

<@Proxy.listCreateProxies ; isFirst, createProxy>
#include "${createProxy.proxyClassName}.h"
</@Proxy.listCreateProxies>
</#if>

<#if superProxyClassName != "EventEmitter">
#include "${superPackageName}.${superProxyClassName}.h"
</#if>

#define TAG "${proxyClassName}"

using namespace v8;

<@Proxy.openNamespace/>

<#assign className = Proxy.className(proxyClassName)>

Persistent<FunctionTemplate> ${className}::proxyTemplate = Persistent<FunctionTemplate>();
jclass ${className}::javaClass = NULL;

${className}::${className}(jobject javaObject) : JavaObject(javaObject)
{
}

void ${className}::Initialize(Handle<Object> ti)
{
	LOGD(TAG, "Initialize");

	<#-- Query the class for the Java proxy -->
	javaClass = JNIUtil::findClass("${packageName?replace('.','/')}/${className}");

	HandleScope scope;

	Local<FunctionTemplate> t = FunctionTemplate::New(${className}::Constructor);
	proxyTemplate = Persistent<FunctionTemplate>::New(t);
	proxyTemplate->InstanceTemplate()->SetInternalFieldCount(ProxyFactory::kInternalFieldCount);
	proxyTemplate->SetClassName(String::NewSymbol("${proxyAttrs.name}"));
	<#if superProxyClassName != "EventEmitter">
	proxyTemplate->Inherit(${superProxyClassName?replace("BindingGen", "")}::proxyTemplate);
	<#else>
	proxyTemplate->Inherit(EventEmitter::constructorTemplate);
	</#if>

	// Method bindings -----------------------------------------------------------
	<@Proxy.listMethods ; isFirst, name, method, signature>
	V8_SET_PROTOTYPE_METHOD(proxyTemplate, "${name}", ${className}::${name});
	</@Proxy.listMethods>

	<#-- Register with the Proxy factory -->
	ProxyFactory::registerProxyPair(javaClass, *proxyTemplate);

	Local<Function> proxyConstructor = proxyTemplate->GetFunction();
	<#if isModule>
	Local<Object> moduleInstance = proxyConstructor->NewInstance();
	ti->Set(String::NewSymbol("${proxyAttrs.name}"), moduleInstance);

	<@Proxy.listChildModules ; isFirst, childModule>
	<@Proxy.namespace proxy=childModule/>${Proxy.className(childModule.name)}Module::Initialize(moduleInstance);
	</@Proxy.listChildModules>

	<@Proxy.listCreateProxies ; isFirst, createProxy>
	<@Proxy.namespace proxy=createProxy/>${Proxy.className(createProxy.name)}Proxy::Initialize(moduleInstance);
	</@Proxy.listCreateProxies>
	<#else>
	ti->Set(String::NewSymbol("${proxyAttrs.name}"), proxyConstructor);
	</#if>
}

Handle<Value> ${className}::Constructor(const Arguments& args)
{
	LOGD(TAG, "Constructor");

	if (!args.IsConstructCall()) {
		return JSException::CalledConstructor();
	}

	HandleScope scope;
	Local<Object> v8Proxy = args.This();

	// If ProxyFactory::createV8Proxy invoked us, unwrap
	// the pre-created Java proxy it sent.
	jobject javaProxy = ProxyFactory::unwrapJavaProxy(args);
	bool deleteRef = false;
	if (!javaProxy) {
		javaProxy = ProxyFactory::createJavaProxy(javaClass, v8Proxy, args);
		deleteRef = true;
	}

	// Initialize the internal property cache used for lazy initializing modules
	v8Proxy->SetInternalField(ProxyFactory::kPropertyCache, Object::New());

	// Set our Titanium API namespace so lazy initialization can work
	<#assign tiNamespace = proxyAttrs.fullAPIName?replace("Titanium.", "")>
	<#assign tiNamespace = tiNamespace?replace("Titanium", "")>
	v8Proxy->SetInternalField(ProxyFactory::kTiNamespace, String::New("${tiNamespace}"));

	${className}* v8ProxyNative = new ${className}(javaProxy);
	v8ProxyNative->Wrap(v8Proxy);

	if (deleteRef) {
		JNIEnv *env = JNIScope::getEnv();
		if (env) {
			env->DeleteLocalRef(javaProxy);
		}
	}
	LOGD(TAG, "Exit Constructor");

	return v8Proxy;
}

// Methods ---------------------------------------------------------------
<@Proxy.listMethods ; isFirst, name, method, signature>
Handle<Value> ${className}::${name}(const Arguments& args)
{
	LOGD(TAG, "${name}()");

	HandleScope scope;
	JNIEnv *env = JNIScope::getEnv();
	if (!env) {
		return JSException::GetJNIEnvironmentError();
	}

	<#-- Lazy initialize method ID for the Java proxy. -->
	static jmethodID methodID = NULL;
	if (!methodID) {
		methodID = env->GetMethodID(${className}::javaClass, "${name}", "${signature}");
		if (!methodID) {
			return JSException::Error("Couldn't find proxy method '${name}' with signature '${signature}'");
		}
	}

	${className}* proxy = NativeObject::Unwrap<${className}>(args.Holder());

	<#if method.args?size &gt; 0>
	<@Proxy.verifyAndConvertArguments method.args />
	<#else>
	jvalue* jArguments = 0;
	</#if>

	<@Proxy.callJNIMethod method.returnType, "methodID", "proxy->getJavaObject()", "jArguments" ;
		hasResult, resultVar>
	<#if hasResult>
	return ${resultVar};
	<#else>
	return v8::Undefined();
	</#if>
	</@Proxy.callJNIMethod>
}

</@Proxy.listMethods>

<@Proxy.closeNamespace/>
