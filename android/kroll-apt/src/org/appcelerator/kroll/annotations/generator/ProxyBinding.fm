<#macro getRequiredArgumentCount args>
	<#local count = 0>
	<#list args as arg>
		<#if arg?keys?seq_contains("optional")>
			<#if !arg.optional>
				<#local count = count + 1>
			</#if>
		<#elseif arg.type = "java.lang.Object[]">
			<#break>
		<#else>
			<#local count = count + 1>
		</#if>
	</#list>
	<#nested count>
</#macro>

<#macro listChildModules>
	<#if isModule>
		<#list allModules?keys as module>
			<#if module = packageName+"."+proxyClassName>
				<#if allModules[module].childModules??>
					<#list allModules[module].childModules as childModule>
						<#nested childModule_index==0, childModule>
					</#list>
				</#if>
			</#if>
		</#list>
	</#if>
</#macro>

<#macro listCreateProxies>
	<#if isModule>
		<#list allModules?keys as module>
			<#if module = packageName+"."+proxyClassName>
				<#if allModules[module].createProxies??>
					<#list allModules[module].createProxies as createProxy>
						<#nested createProxy_index==0, createProxy>
					</#list>
				</#if>
			</#if>
		</#list>
	</#if>
</#macro>

<#macro listMethods>
	<#if methods??>
		<#list methods?keys as methodName>
			<#local method = methods[methodName]>
			<#local signature>
				<@getMethodSignature method.args, method.returnType />
			</#local>
			<#nested methodName_index==0, methodName, method, signature>
		</#list>
	</#if>
</#macro>

<#assign typeInfo = {
	"java.lang.String":{
		"jsType":"Value",
		"jsValidation":false,
		"jsToJavaConverter":"jsValueToJavaString",
		"javaToJsConverter":"javaStringToJsString",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jstring"
	},
	"java.lang.Object":{
		"jsType":"Object",
		"jsConvertType":"Value",
		"jsToJavaConverter":"jsValueToJavaObject",
		"javaToJsConverter":"javaObjectToJsValue",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject"
	},
	"java.lang.Object[]":{
		"jsType":"Array",
		"jsHandleCast":"Array",
		"jsToJavaConverter":"jsArrayToJavaArray",
		"javaToJsConverter":"javaArrayToJsArray",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobjectArray"
	},
	"int[]":{
		"jsType":"Array",
		"jsHandleCast":"Array",
		"jsToJavaConverter":"jsArrayToJavaArray",
		"javaToJsConverter":"javaArrayToJsArray",
		"jvalue":"l", "signature":"[I",
		"javaCallMethodType":"Object",
		"javaReturnType":"jintArray"
	},
	"int":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaInt",
		"javaToJsConverter":"javaIntToJsNumber",
		"jvalue":"i", "signature":"I",
		"javaCallMethodType":"Int",
		"javaReturnType":"jint"
	},
	"short":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaShort",
		"javaToJsConverter":"javaShortToJsNumber",
		"jvalue":"s", "signature":"S",
		"javaCallMethodType":"Short",
		"javaReturnType":"jshort"
	},
	"long":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaLong",
		"javaToJsConverter":"javaLongToJsNumber",
		"jvalue":"j", "signature":"J",
		"javaCallMethodType":"Long",
		"javaReturnType":"jlong"
	},
	"float":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaFloat",
		"javaToJsConverter":"javaFloatToJsNumber",
		"jvalue":"f", "signature":"F",
		"javaCallMethodType":"Float",
		"javaReturnType":"jfloat"
	},
	"double":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaDouble",
		"javaToJsConverter":"javaDoubleToJsNumber",
		"jvalue":"d", "signature":"D",
		"javaCallMethodType":"Double",
		"javaReturnType":"jdouble"
	},
	"boolean":{
		"jsType":"Boolean",
		"jsToJavaConverter":"jsBooleanToJavaBoolean",
		"javaToJsConverter":"javaBooleanToJsBoolean",
		"jvalue":"z", "signature":"Z",
		"javaCallMethodType":"Boolean",
		"javaReturnType":"jboolean"
	},
	"void":{
		"signature":"V",
		"javaCallMethodType":"Void",
		"javaReturnType":"void"
	}
}>

<#function getTypeInfo type>
	<#if typeInfo?keys?seq_contains(type)>
		<#return typeInfo[type]>
	</#if>

	<#if type?contains(".")>
		<#return typeInfo["java.lang.Object"]>
	</#if>

	<#stop "Unknown type info requested: ${type}">
</#function>

<#macro listMethodArguments args>
	<#list args as arg>
		<#nested arg_index, typeInfo[arg.type]!typeInfo["java.lang.Object"]>
	</#list>
</#macro>

<#function getTypeSignature type>
	<#-- Look up the type's signature. If it does not exist, this
		 type is a Java object. Object signatures take a special format
		 which has the full class name in it (ex: Ljava.lang.Object;) -->
	<#if typeInfo?keys?seq_contains(type) && typeInfo[type]?keys?seq_contains("signature")>
		<#return typeInfo[type].signature>
	<#else>
		<#return "L${type?replace('.', '/')};">
	</#if>
</#function>

<#macro getArgumentsSignature args>
	<#list args as arg>
		<#local signature = getTypeSignature(arg.type)>
		<#nested "${signature}">
	</#list>
</#macro>

<#macro getMethodSignature args returnType>
	(<@getArgumentsSignature args ; s>${s}</@getArgumentsSignature>)${getTypeSignature(returnType)}<#t>
</#macro>

<#macro generateJNICall returnType>
</#macro>

<#--------------------------------------------------------------
Verify and convert V8 values into JNI values inside a V8
invocation callback. The converted values are stored into an
jvalue array named "jArguments". If validation or conversion
fails, a JS exception is returned.
---------------------------------------------------------------->
<#macro verifyAndConvertArguments args>
	<#-- Verify the correct argument count was provided. -->
	<@Proxy.getRequiredArgumentCount args=args ; requiredCount>
	<#if requiredCount &gt; 0>
	if (args.Length() != ${requiredCount})
		//return JSException::MissingRequiredArguments(args.Length(), ${requiredCount});
		return ThrowException(Exception::Error(String::New("")));
	</#if>
	</@Proxy.getRequiredArgumentCount>

	jvalue jArguments[${args?size}];

	<#-- Generate argument validation and conversion code -->
	<@Proxy.listMethodArguments args=args ; index, info>
	<#if info.jsValidation!true>
	if (!args[${index}]->Is${info.jsType}())
		return JSException::Error("Invalid argument at index ${index}. Expected type ${info.jsType}.");
	</#if>

	<#if info.jsType == "Value">
	Local<Value> arg_${index} = args[${index}];
	<#elseif info?keys?seq_contains("jsHandleCast")>
	Local<${info.jsType}> arg_${index} = Local<${info.jsType}>::Cast(args[${index}]);
	<#else>
	Local<${info.jsType}> arg_${index} = args[${index}]->To${info.jsType}();
	</#if>

	jArguments[${index}].${info.jvalue} = TypeConverter::${info.jsToJavaConverter}(arg_${index});
	</@Proxy.listMethodArguments>
</#macro>

<#--------------------------------------------------------------
Generate a JNI method call with the given return type, method ID,
and jobject reference. This macro also expects a jvalue array
already exists in the scope name provided in "argsVar".
Outputs the complete statement that performs the JNI call and
stores the return value in "result". A nested section can
beprovided to handle the result.
---------------------------------------------------------------->
<#macro callJNIMethod returnType methodID jobjectVar argsVar>
	<#local info = getTypeInfo(returnType)
			callExpr = "Call${info.javaCallMethodType}MethodA"
			argExpr = "${jobjectVar}, ${methodID}, ${argsVar}"
			resultExpr = "${info.javaReturnType} jResult = (${info.javaReturnType})"
			hasResult = info.javaReturnType != "void">
	<#if hasResult>
	${resultExpr}env->${callExpr}(${argExpr});

	<#local jsType = info.jsType>
	<#if info?keys?seq_contains("jsConvertType")>
		<#local jsType = info.jsConvertType>
	</#if>

	Handle<${jsType}> v8Result = TypeConverter::${info.javaToJsConverter}(jResult);
	<#else>
	env->${callExpr}(${argExpr});
	</#if>

	<#nested hasResult "v8Result">
</#macro>

