<#macro getRequiredArgumentCount args>
	<#local count = 0>
	<#list args as arg>
		<#if arg?keys?seq_contains("optional")>
			<#if !arg.optional>
				<#local count = count + 1>
			</#if>
		<#elseif arg.type = "java.lang.Object[]">
			<#break>
		<#else>
			<#local count = count + 1>
		</#if>
	</#list>
	<#nested count>
</#macro>

<#macro listChildModules>
	<#if isModule>
		<#list allModules?keys as module>
			<#if module = packageName+"."+proxyClassName>
				<#if allModules[module].childModules??>
					<#list allModules[module].childModules as childModule>
						<#nested childModule_index==0, childModule>
					</#list>
				</#if>
			</#if>
		</#list>
	</#if>
</#macro>

<#macro listCreateProxies>
	<#if isModule>
		<#list allModules?keys as module>
			<#if module = packageName+"."+proxyClassName>
				<#if allModules[module].createProxies??>
					<#list allModules[module].createProxies as createProxy>
						<#nested createProxy_index==0, createProxy>
					</#list>
				</#if>
			</#if>
		</#list>
	</#if>
</#macro>

<#macro listMethods>
	<#if methods??>
		<#list methods?keys as methodName>
			<#local method = methods[methodName]>
			<#local signature>
				<@getMethodSignature method.args, method.returnType />
			</#local>
			<#nested methodName_index==0, methodName, method, signature>
		</#list>
	</#if>
</#macro>

<#macro listConstants>
	<#if constants??>
		<#list constants?keys as constantName>
			<#local constant = constants[constantName]>
			<#nested constantName_index==0, constantName, constant>
		</#list>
	</#if>
</#macro>

<#macro listProperties>
	<#if properties??>
		<#list properties?keys as propertyName>
			<#local property = properties[propertyName]>
			<#nested propertyName_index==0, propertyName, property>
		</#list>
	</#if>
</#macro>

<#macro listDynamicProperties>
	<#if dynamicProperties??>
		<#list dynamicProperties?keys as propertyName>
			<#local dynamicProperty = dynamicProperties[propertyName]>
			<#if dynamicProperty.get>
				<#local getSignature>
					<@getMethodSignature dynamicProperty.getMethodArgs, dynamicProperty.getReturnType />
				</#local>
			<#else>
				<#local getSignature = "">
			</#if>
			<#if dynamicProperty.set>
				<#local setSignature>
					<@getMethodSignature dynamicProperty.setMethodArgs, dynamicProperty.setReturnType />
				</#local>
			<#else>
				<#local setSignature = "">
			</#if>
			<#nested propertyName_index==0, propertyName, dynamicProperty, getSignature, setSignature>
		</#list>
	</#if>
</#macro>

<#-- returns whether or not a method name has @Kroll.getProperty or @Kroll.setProperty -->
<#function isDynamicProperty methodName>
	<#if dynamicProperties??>
		<#list dynamicProperties?keys as propertyName>
			<#local dynamicProperty = dynamicProperties[propertyName]>
			<#if dynamicProperty.get>
				<#if methodName = dynamicProperty.getMethodName>
					<#return true>
				</#if>
			</#if>
			<#if dynamicProperty.set>
				<#if methodName = dynamicProperty.setMethodName>
					<#return true>
				</#if>
			</#if>
		</#list>
	</#if>
	<#return false>
</#function>

<#macro listPropertyAccessors>
	<#list proxyAttrs.propertyAccessors as accessor>
		<#local upperCamel = accessor?substring(0, 1)?upper_case + accessor?substring(1)>
		<#nested accessor_index==0, accessor, "get" + upperCamel, "set" + upperCamel>
	</#list>
</#macro>

<#macro openNamespace>
namespace titanium {
	<#list proxyAttrs.fullAPIName?split(".") as ns>
		<#if ns_has_next && ns?lower_case != "titanium">
			namespace ${ns?lower_case} {
		</#if>
	</#list>
</#macro>

<#macro closeNamespace>
	<#list proxyAttrs.fullAPIName?split(".")?reverse as ns>
		<#if ns_index != 0 && ns?lower_case != "titanium">
			} // namespace ${ns?lower_case}
		</#if>
	</#list>
} // namespace titanium
</#macro>

<#macro namespace proxy>
<#compress>
titanium::<#list proxy.fullAPIName?split(".") as ns>
		<#if ns_has_next && ns?lower_case != "titanium">
			${ns?lower_case}::
		</#if>
	</#list>
</#compress>
</#macro>

<#function className name>
	<#if name?matches("^[0-9].+")>
		<#return "_" + name>
	<#else>
		<#return name>
	</#if>
</#function>

<#assign typeInfo = {
	"java.lang.String":{
		"jsType":"Value",
		"jsValidation":false,
		"jsToJavaConverter":"jsValueToJavaString",
		"javaToJsConverter":"javaStringToJsString",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jstring",
		"javaValidation":true
	},
	"java.lang.Object":{
		"jsType":"Value",
		"jsValidation":false,
		"jsConvertType":"Value",
		"jsToJavaConverter":"jsValueToJavaObject",
		"javaToJsConverter":"javaObjectToJsValue",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject",
		"javaValidation":true
	},
	"java.lang.Object[]":{
		"jsType":"Array",
		"jsHandleCast":"Array",
		"jsToJavaConverter":"jsArrayToJavaArray",
		"javaToJsConverter":"javaArrayToJsArray",
		"jvalue":"l", "signature":"[Ljava/lang/Object;",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobjectArray",
		"javaValidation": true
	},
	"int[]":{
		"jsType":"Array",
		"jsHandleCast":"Array",
		"jsToJavaConverter":"jsArrayToJavaArray",
		"javaToJsConverter":"javaArrayToJsArray",
		"jvalue":"l", "signature":"[I",
		"javaCallMethodType":"Object",
		"javaReturnType":"jintArray",
		"javaValidation":true
	},
	"int":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaInt",
		"javaToJsConverter":"javaIntToJsNumber",
		"jvalue":"i", "signature":"I",
		"javaCallMethodType":"Int",
		"javaReturnType":"jint"
	},
	"short":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaShort",
		"javaToJsConverter":"javaShortToJsNumber",
		"jvalue":"s", "signature":"S",
		"javaCallMethodType":"Short",
		"javaReturnType":"jshort"
	},
	"long":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaLong",
		"javaToJsConverter":"javaLongToJsNumber",
		"jvalue":"j", "signature":"J",
		"javaCallMethodType":"Long",
		"javaReturnType":"jlong"
	},
	"float":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaFloat",
		"javaToJsConverter":"javaFloatToJsNumber",
		"jvalue":"f", "signature":"F",
		"javaCallMethodType":"Float",
		"javaReturnType":"jfloat"
	},
	"double":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaDouble",
		"javaToJsConverter":"javaDoubleToJsNumber",
		"jvalue":"d", "signature":"D",
		"javaCallMethodType":"Double",
		"javaReturnType":"jdouble"
	},
	"boolean":{
		"jsType":"Boolean",
		"jsToJavaConverter":"jsBooleanToJavaBoolean",
		"javaToJsConverter":"javaBooleanToJsBoolean",
		"jvalue":"z", "signature":"Z",
		"javaCallMethodType":"Boolean",
		"javaReturnType":"jboolean"
	},
	"void":{
		"signature":"V",
		"javaCallMethodType":"Void",
		"javaReturnType":"void"
	}
}>

<#function getTypeInfo type>
	<#if typeInfo?keys?seq_contains(type)>
		<#return typeInfo[type]>
	</#if>

	<#if type?contains(".")>
		<#return typeInfo["java.lang.Object"]>
	</#if>

	<#stop "Unknown type info requested: ${type}">
</#function>

<#macro listMethodArguments args>
	<#list args as arg>
		<#nested arg_index, typeInfo[arg.type]!typeInfo["java.lang.Object"], arg.type>
	</#list>
</#macro>

<#function getTypeSignature type>
	<#-- Look up the type's signature. If it does not exist, this
		 type is a Java object. Object signatures take a special format
		 which has the full class name in it (ex: Ljava.lang.Object;) -->
	<#if typeInfo?keys?seq_contains(type) && typeInfo[type]?keys?seq_contains("signature")>
		<#return typeInfo[type].signature>
	<#else>
		<#local jniType = type?replace(".", "/")>
		<#local prefix = "L">
		<#if type?ends_with("[]")>
			<#local jniType = jniType?substring(0, jniType?length - 2)>
			<#local prefix = "[L">
		</#if>
		<#return prefix + jniType + ";">
	</#if>
</#function>

<#macro getArgumentsSignature args>
	<#list args as arg>
		<#local signature = getTypeSignature(arg.type)>
		<#nested "${signature}">
	</#list>
</#macro>

<#macro getMethodSignature args returnType>
	(<@getArgumentsSignature args ; s>${s}</@getArgumentsSignature>)${getTypeSignature(returnType)}<#t>
</#macro>

<#macro generateJNICall returnType>
</#macro>

<#--------------------------------------------------------------
Verify and convert V8 values into JNI values inside a V8
invocation callback. The converted values are stored into an
jvalue array named "jArguments". If validation or conversion
fails, a JS exception is returned.
---------------------------------------------------------------->
<#macro verifyAndConvertArgument expr index info logOnly>
	<#if info.jsValidation!true>
	if (!${expr}->Is${info.jsType}()) {
		const char *error = "Invalid value, expected type ${info.jsType}.";
		LOGE(TAG, error);
		<#if !(logOnly!false)>
		return JSException::Error(error);
		</#if>
	}
	</#if>

	<#if info.jsType == "Value">
	Local<Value> arg_${index} = ${expr};
	<#elseif info?keys?seq_contains("jsHandleCast")>
	Local<${info.jsType}> arg_${index} = Local<${info.jsType}>::Cast(${expr});
	<#else>
	Local<${info.jsType}> arg_${index} = ${expr}->To${info.jsType}();
	</#if>

	jArguments[${index}].${info.jvalue} = TypeConverter::${info.jsToJavaConverter}(arg_${index});
</#macro>

<#macro convertToVarArgs args start>
	uint32_t length = args.Length() - ${start};
	if (length < 0) {
		length = 0;
	}

	jobjectArray varArgs = env->NewObjectArray(length, JNIUtil::objectClass, NULL);
	for (uint32_t i = 0; i < length; ++i) {
		env->SetObjectArrayElement(varArgs, i, TypeConverter::jsValueToJavaObject(args[i+${start}])); 
	}

	jArguments[${start}].l = varArgs;
</#macro>

<#macro verifyAndConvertArguments args method>
	<#-- Verify the correct argument count was provided. -->
	<@Proxy.getRequiredArgumentCount args=args ; requiredCount>
	<#if requiredCount &gt; 0>
	if (args.Length() < ${requiredCount})
	{
		char errorStringBuffer[100];
		sprintf(errorStringBuffer, "invalid number of arguments.  Expected ${requiredCount} but got %d", args.Length());
		return ThrowException(Exception::Error(String::New(errorStringBuffer)));
	}
	</#if>
	</@Proxy.getRequiredArgumentCount>

	jvalue jArguments[${args?size}];

	<#-- Generate argument validation and conversion code -->
	<#local varArgsIndex = -1>
	<#list args as arg>
		<#if arg.type == "java.lang.Object[]" && arg_index = args?size - 1>
			<#local varArgsIndex = arg_index>
		</#if>
	</#list>

	<#if method.hasInvocation>
	jArguments[0].l = env->NewObject(JNIUtil::v8InvocationClass, JNIUtil::v8InvocationInitMethod, TypeConverter::jsValueToJavaString(args[0]));
	</#if>

	<@Proxy.listMethodArguments args=args ; index, info, type>

	<#if type != "org.appcelerator.kroll.runtime.v8.V8Invocation">
		<#if index = varArgsIndex>
			<@Proxy.convertToVarArgs args=args start=index/>
		<#else>
			<@Proxy.verifyAndConvertArgument expr="args[" + index + "]" index=index info=info logOnly=false/>
		</#if>
	</#if>
	</@Proxy.listMethodArguments>
</#macro>

<#--------------------------------------------------------------
Generate a JNI method call with the given return type, method ID,
and jobject reference. This macro also expects a jvalue array
already exists in the scope name provided in "argsVar".
Outputs the complete statement that performs the JNI call and
stores the return value in "result". A nested section can
beprovided to handle the result.
---------------------------------------------------------------->
<#macro callJNIMethod returnType methodID jobjectVar argsVar>
	<#local info = getTypeInfo(returnType)
			callExpr = "Call${info.javaCallMethodType}MethodA"
			argExpr = "${jobjectVar}, ${methodID}, ${argsVar}"
			resultExpr = "${info.javaReturnType} jResult = (${info.javaReturnType})"
			hasResult = info.javaReturnType != "void">
	<#if hasResult>
	${resultExpr}env->${callExpr}(${argExpr});

	if (env->ExceptionCheck()) {
		Handle<Value> jsException = JSException::fromJavaException();
		env->ExceptionClear();
		return jsException;
	}

	<#if info.javaValidation!false>
	if (jResult == NULL) {
		return Null();
	}
	</#if>

	<#local jsType = info.jsType>
	<#if info?keys?seq_contains("jsConvertType")>
		<#local jsType = info.jsConvertType>
	</#if>

	Handle<${jsType}> v8Result = TypeConverter::${info.javaToJsConverter}(jResult);
	<#else>
	env->${callExpr}(${argExpr});
	</#if>

	<#nested hasResult "v8Result">
</#macro>

<#macro initJNIEnv>
	JNIEnv *env = JNIScope::getEnv();
	if (!env) {
		return JSException::GetJNIEnvironmentError();
	}
</#macro>

<#macro initMethodID className name signature logOnly>
	<#-- Lazy initialize method ID for the Java proxy. -->
	static jmethodID methodID = NULL;
	if (!methodID) {
		methodID = env->GetMethodID(${className}::javaClass, "${name}", "${signature}");
		if (!methodID) {
			const char *error = "Couldn't find proxy method '${name}' with signature '${signature}'";
			LOGE(TAG, error);
			<#if !(logOnly!false)>
				return JSException::Error(error);
			</#if>
		}
	}
</#macro>
