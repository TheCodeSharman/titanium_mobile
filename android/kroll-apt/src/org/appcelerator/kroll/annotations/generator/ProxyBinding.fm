<#macro getRequiredArgumentCount args>
	<#local count = 0>
	<#list args as arg>
		<#if arg?keys?seq_contains("optional")>
			<#if !arg.optional>
				<#local count = count + 1>
			</#if>
		<#elseif arg.type = "java.lang.Object[]">
			<#break>
		<#else>
			<#local count = count + 1>
		</#if>
	</#list>
	<#nested count>
</#macro>

<#macro listMethods>
	<#if methods??>
		<#list methods?keys as methodName>
			<#local method = methods[methodName]>
			<#local signature>
				<@getMethodSignature method.args, method.returnType />
			</#local>
			<#nested methodName_index==0, methodName, method, signature>
		</#list>
	</#if>
</#macro>

<#assign typeInfo = {
	"java.lang.String":{
		"jsType":"String",
		"converter":"jsStringToJavaString",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject"
	},
	"java.lang.Object":{
		"jsType":"Object",
		"converter":"jsObjectToJavaObject",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject"
	},
	"int":{
		"jsType":"Number",
		"converter":"jsNumberToJavaInt",
		"jvalue":"i", "signature":"I",
		"javaCallMethodType":"Int",
		"javaReturnType":"jint"
	},
	"short":{
		"jsType":"Number",
		"converter":"jsNumberToJavaShort",
		"jvalue":"s", "signature":"S",
		"javaCallMethodType":"Short",
		"javaReturnType":"jshort"
	},
	"long":{
		"jsType":"Number",
		"converter":"jsNumberToJavaLong",
		"jvalue":"j", "signature":"J",
		"javaCallMethodType":"Long",
		"javaReturnType":"jlong"
	},
	"float":{
		"jsType":"Number",
		"converter":"jsNumberToJavaFloat",
		"jvalue":"f", "signature":"F",
		"javaCallMethodType":"Float",
		"javaReturnType":"jfloat"
	},
	"double":{
		"jsType":"Number",
		"converter":"jsNumberToDouble",
		"jvalue":"d", "signature":"D",
		"javaCallMethodType":"Double",
		"javaReturnType":"jdouble"
	},
	"boolean":{
		"jsType":"Boolean",
		"converter":"jsBooleanToJavaBoolean",
		"jvalue":"z", "signature":"Z",
		"javaCallMethodType":"Boolean",
		"javaReturnType":"jboolean"
	},
	"void":{
		"signature":"V",
		"javaCallMethodType":"Void",
		"javaReturnType":"void"
	}
}>

<#function getTypeInfo type>
	<#if typeInfo?keys?seq_contains(type)>
		<#return typeInfo[type]>
	</#if>

	<#if type?contains(".")>
		<#return typeInfo["java.lang.Object"]>
	</#if>

	<#stop "Unknown type info requested: ${type}">
</#function>

<#macro listMethodArguments args>
	<#list args as arg>
		<#nested arg_index, typeInfo[arg.type]!typeInfo["java.lang.Object"]>
	</#list>
</#macro>

<#function getTypeSignature type>
	<#-- Look up the type's signature. If it does not exist, this
		 type is a Java object. Object signatures take a special format
		 which has the full class name in it (ex: Ljava.lang.Object;) -->
	<#if typeInfo?keys?seq_contains(type) && typeInfo[type]?keys?seq_contains("signature")>
		<#return typeInfo[type].signature>
	<#else>
		<#return "L${type?replace('.', '/')};">
	</#if>
</#function>

<#macro getArgumentsSignature args>
	<#list args as arg>
		<#local signature = getTypeSignature(arg.type)>
		<#nested "${signature}">
	</#list>
</#macro>

<#macro getMethodSignature args returnType>
	(<@getArgumentsSignature args ; s>${s}</@getArgumentsSignature>)${getTypeSignature(returnType)}<#t>
</#macro>

<#macro generateJNICall returnType>
	<#local info = getTypeInfo(returnType)>
	<#local callMethod = "Call${info.javaCallMethodType}MethodA">
	<#nested info.javaReturnType callMethod>
</#macro>

