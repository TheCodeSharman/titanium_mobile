<#macro getRequiredArgumentCount args>
	<#local count = 0>
	<#list args as arg>
		<#if arg?keys?seq_contains("optional")>
			<#if !arg.optional>
				<#local count = count + 1>
			</#if>
		<#elseif arg.type = "java.lang.Object[]">
			<#break>
		<#else>
			<#local count = count + 1>
		</#if>
	</#list>
	<#nested count>
</#macro>

<#macro listMethods>
	<#if methods??>
		<#list methods?keys as methodName>
			<#local method = methods[methodName]>
			<#local signature>
				<@getMethodSignature method.args, method.returnType />
			</#local>
			<#nested methodName_index==0, methodName, method, signature>
		</#list>
	</#if>
</#macro>

<#assign typeInfo = {
	"java.lang.String":{
		"jsType":"String",
		"jsToJavaConverter":"jsStringToJavaString",
		"javaToJsConverter":"javaStringToJsString",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject"
	},
	"java.lang.Object":{
		"jsType":"Object",
		"jsToJavaConverter":"jsObjectToJavaObject",
		"javaToJsConverter":"javaObjectToJsObject",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobject"
	},
	"java.lang.Object[]":{
		"jsType":"Array",
		"jsToJavaConverter":"jsArrayToJavaArray",
		"javaToJsConverter":"javaArrayToJsArray",
		"jvalue":"l",
		"javaCallMethodType":"Object",
		"javaReturnType":"jobjectArray"
	},
	"int":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaInt",
		"javaToJsConverter":"javaIntToJsNumber",
		"jvalue":"i", "signature":"I",
		"javaCallMethodType":"Int",
		"javaReturnType":"jint"
	},
	"short":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaShort",
		"javaToJsConverter":"javaShortToJsNumber",
		"jvalue":"s", "signature":"S",
		"javaCallMethodType":"Short",
		"javaReturnType":"jshort"
	},
	"long":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaLong",
		"javaToJsConverter":"javaLongToJsNumber",
		"jvalue":"j", "signature":"J",
		"javaCallMethodType":"Long",
		"javaReturnType":"jlong"
	},
	"float":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaFloat",
		"javaToJsConverter":"javaFloatToJsNumber",
		"jvalue":"f", "signature":"F",
		"javaCallMethodType":"Float",
		"javaReturnType":"jfloat"
	},
	"double":{
		"jsType":"Number",
		"jsToJavaConverter":"jsNumberToJavaDouble",
		"javaToJsConverter":"javaDoubleToJsNumber",
		"jvalue":"d", "signature":"D",
		"javaCallMethodType":"Double",
		"javaReturnType":"jdouble"
	},
	"boolean":{
		"jsType":"Boolean",
		"jsToJavaConverter":"jsBooleanToJavaBoolean",
		"javaToJsConverter":"javaBoolToJsBoolean",
		"jvalue":"z", "signature":"Z",
		"javaCallMethodType":"Boolean",
		"javaReturnType":"jboolean"
	},
	"void":{
		"signature":"V",
		"javaCallMethodType":"Void",
		"javaReturnType":"void"
	}
}>

<#function getTypeInfo type>
	<#if typeInfo?keys?seq_contains(type)>
		<#return typeInfo[type]>
	</#if>

	<#if type?contains(".")>
		<#return typeInfo["java.lang.Object"]>
	</#if>

	<#stop "Unknown type info requested: ${type}">
</#function>

<#macro listMethodArguments args>
	<#list args as arg>
		<#nested arg_index, typeInfo[arg.type]!typeInfo["java.lang.Object"]>
	</#list>
</#macro>

<#function getTypeSignature type>
	<#-- Look up the type's signature. If it does not exist, this
		 type is a Java object. Object signatures take a special format
		 which has the full class name in it (ex: Ljava.lang.Object;) -->
	<#if typeInfo?keys?seq_contains(type) && typeInfo[type]?keys?seq_contains("signature")>
		<#return typeInfo[type].signature>
	<#else>
		<#return "L${type?replace('.', '/')};">
	</#if>
</#function>

<#macro getArgumentsSignature args>
	<#list args as arg>
		<#local signature = getTypeSignature(arg.type)>
		<#nested "${signature}">
	</#list>
</#macro>

<#macro getMethodSignature args returnType>
	(<@getArgumentsSignature args ; s>${s}</@getArgumentsSignature>)${getTypeSignature(returnType)}<#t>
</#macro>

<#macro generateJNICall returnType>
</#macro>

<#--------------------------------------------------------------
Verify and convert V8 values into JNI values inside a V8
invocation callback. The converted values are stored into an
jvalue array named "jArguments". If validation or conversion
fails, a JS exception is returned.
---------------------------------------------------------------->
<#macro verifyAndConvertArguments args>
	<#if args?size == 0><#return></#if>
	<@Proxy.getRequiredArgumentCount args=args ; requiredCount>
	<#if requiredCount &gt; 0>
	if (args.Length() != ${requiredCount})
		return JSException::MissingRequiredArguments(args.Length(), ${requiredCount});
	</#if>
	</@Proxy.getRequiredArgumentCount>

	jvalue jArguments[${args?size}];

	<@Proxy.listMethodArguments args=args ; index, info>
	Local<Value> arg = args[${index}];
	if (!arg->Is${info.jsType}()) {
			return JSException::InvalidArgument(${index}, ${info.jsType});
	}
	jArguments[${index}].${info.jvalue} = TypeConverter::${info.jsToJavaConverter}(arg->To${info.jsType}());

	</@Proxy.listMethodArguments>
</#macro>

<#--------------------------------------------------------------
Generate a JNI method call with the given return type, method ID,
and jobject reference. This macro also expects a jvalue array
already exists in the scope name provided in "argsVar".
Outputs the complete statement that performs the JNI call and
stores the return value in "result". A nested section can
beprovided to handle the result.
---------------------------------------------------------------->
<#macro callJNIMethod returnType methodID jobjectVar argsVar>
	<#local info = getTypeInfo(returnType)
			callExpr = "Call${info.javaCallMethodType}MethodA"
			argExpr = "${jobjectVar}, ${methodID}, ${argsVar}"
			resultExpr = "${info.javaReturnType} jResult = "
			hasResult = info.javaReturnType != "void">
	<#if hasResult>
	${resultExpr}${callExpr}(${argExpr});
	Handle<${info.jsType}> v8Result = TypeConverter::${info.javaToJsConverter}(jResult);
	<#else>
	${callExpr}(${argExpr});
	</#if>

	<#nested hasResult "v8Result">
</#macro>

